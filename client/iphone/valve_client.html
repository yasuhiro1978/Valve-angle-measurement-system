<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ãƒãƒ«ãƒ–è§’åº¦è¨ˆæ¸¬ - iPhone Client</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow-x: hidden;
        }
        
        .container {
            padding: 15px;
            max-width: 100%;
        }
        
        .card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            background: rgba(255,255,255,0.95);
            margin-bottom: 15px;
        }
        
        /* å¤§ããªãƒœã‚¿ãƒ³ï¼ˆ80pxä»¥ä¸Šï¼‰ */
        .btn-large {
            width: 100%;
            min-height: 80px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 15px;
            margin-bottom: 10px;
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .btn-large:active {
            transform: scale(0.95);
        }
        
        .btn-calibration {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-measure {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }
        
        .btn-save {
            background: linear-gradient(45deg, #764ba2, #667eea);
            color: white;
        }
        
        .btn-next {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            color: white;
        }
        
        /* ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ */
        .camera-preview {
            position: relative;
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .camera-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .camera-preview canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* ROIçŸ©å½¢ */
        .roi-rectangle {
            position: absolute;
            border: 3px solid #28a745;
            background: rgba(40, 167, 69, 0.1);
            cursor: move;
            pointer-events: auto;
        }
        
        .roi-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #28a745;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
        }
        
        /* å¯¾è±¡ã‚¿ã‚¤ãƒ—ã‚¿ãƒ– */
        .target-type-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .target-type-tabs .btn {
            flex: 1;
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .target-type-tabs .btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected {
            background-color: #28a745;
            animation: pulse 2s infinite;
        }
        
        .status-disconnected {
            background-color: #dc3545;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ãƒ­ã‚°è¡¨ç¤º */
        .log-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .log-message {
            margin-bottom: 3px;
            padding: 2px 0;
        }
        
        .log-info { color: #007bff; }
        .log-success { color: #28a745; }
        .log-warning { color: #ffc107; }
        .log-error { color: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <div class="card">
            <div class="card-body text-center">
                <h4><i class="fas fa-radar me-2"></i>ãƒãƒ«ãƒ–è§’åº¦è¨ˆæ¸¬</h4>
                <div class="d-flex align-items-center justify-content-center">
                    <span class="status-indicator status-disconnected" id="connectionStatus"></span>
                    <span id="connectionText">æœªæ¥ç¶š</span>
                </div>
            </div>
        </div>
        
        <!-- ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ + ROIé¸æŠ -->
        <div class="card">
            <div class="card-body">
                <h6 class="mb-3">ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h6>
                <div class="camera-preview" id="cameraPreview">
                    <video id="cameraVideo" autoplay playsinline></video>
                    <canvas id="pointCloudCanvas"></canvas>
                    <div class="roi-rectangle" id="roiRectangle" style="display: none;">
                        <div class="roi-handle" style="top: -6px; left: -6px;"></div>
                        <div class="roi-handle" style="top: -6px; right: -6px;"></div>
                        <div class="roi-handle" style="bottom: -6px; left: -6px;"></div>
                        <div class="roi-handle" style="bottom: -6px; right: -6px;"></div>
                    </div>
                </div>
                <small class="text-muted">ğŸ“ ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ROIã‚’é¸æŠ</small>
            </div>
        </div>
        
        <!-- å¯¾è±¡ã‚¿ã‚¤ãƒ—é¸æŠ -->
        <div class="card">
            <div class="card-body">
                <h6 class="mb-3">å¯¾è±¡ã‚¿ã‚¤ãƒ—</h6>
                <div class="target-type-tabs">
                    <button class="btn btn-outline-primary active" data-type="A" onclick="selectTargetType('A')">
                        A<br><small>ã‚¹ãƒ†ãƒ è»¸</small>
                    </button>
                    <button class="btn btn-outline-primary" data-type="B" onclick="selectTargetType('B')">
                        B<br><small>ãƒãƒ³ãƒ‰ãƒ«é¢</small>
                    </button>
                    <button class="btn btn-outline-primary" data-type="C" onclick="selectTargetType('C')">
                        C<br><small>ãƒ•ãƒ©ãƒ³ã‚¸é¢</small>
                    </button>
                    <button class="btn btn-outline-primary" data-type="D" onclick="selectTargetType('D')">
                        D<br><small>é…ç®¡è»¸</small>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- åŸºæº–æ–¹å¼é¸æŠ -->
        <div class="card">
            <div class="card-body">
                <h6 class="mb-3">åŸºæº–æ–¹å¼</h6>
                <div class="btn-group w-100" role="group">
                    <input type="radio" class="btn-check" name="basis" id="basisImu" value="imu" checked>
                    <label class="btn btn-outline-primary" for="basisImu">IMU â­</label>
                    
                    <input type="radio" class="btn-check" name="basis" id="basisPlane" value="plane">
                    <label class="btn btn-outline-primary" for="basisPlane">å¹³é¢æ¨å®š</label>
                </div>
            </div>
        </div>
        
        <!-- ä¸»è¦ãƒœã‚¿ãƒ³ -->
        <div class="card">
            <div class="card-body">
                <button class="btn btn-large btn-calibration" onclick="startCalibration()">
                    <i class="fas fa-ruler-combined me-2"></i>ğŸ“ åŸºæº–åˆã‚ã›
                </button>
                
                <button class="btn btn-large btn-measure" onclick="startMeasurement()">
                    <i class="fas fa-ruler me-2"></i>ğŸ“ è¨ˆæ¸¬
                </button>
                
                <button class="btn btn-large btn-save" onclick="saveMeasurement()" disabled id="saveBtn">
                    <i class="fas fa-save me-2"></i>ğŸ’¾ ä¿å­˜
                </button>
                
                <button class="btn btn-large btn-next" onclick="nextMeasurement()">
                    <i class="fas fa-arrow-right me-2"></i>â¡ï¸ æ¬¡ã®æ¸¬å®š
                </button>
            </div>
        </div>
        
        <!-- çµ±è¨ˆæƒ…å ± -->
        <div class="card">
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-6">
                        <div class="mb-2">
                            <small class="text-muted">ç‚¹ç¾¤</small>
                            <div id="pointCount">0ç‚¹</div>
                        </div>
                    </div>
                    <div class="col-6">
                        <div class="mb-2">
                            <small class="text-muted">è·é›¢</small>
                            <div id="distance">- m</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ãƒ­ã‚°è¡¨ç¤º -->
        <div class="card">
            <div class="card-body">
                <h6><i class="fas fa-terminal me-2"></i>ãƒ­ã‚°</h6>
                <div class="log-container" id="logContainer">
                    <div class="log-message log-info">ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•ä¸­...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        // ============================================================
        let websocket = null;
        let cameraStream = null;
        let arSession = null;
        let isCalibrated = false;
        let isMeasuring = false;
        let currentTargetType = 'A';
        let currentBasis = 'imu';
        let roiData = null;
        let imuData = {
            gravity: { x: 0, y: 0, z: -9.8 },
            attitude: { pitch: 0, roll: 0, yaw: 0 }
        };
        let currentMeasurement = null;
        
        // ============================================================
        // åˆæœŸåŒ–
        // ============================================================
        document.addEventListener('DOMContentLoaded', function() {
            logMessage('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...', 'info');
            
            // åˆå›èµ·å‹•ãƒã‚§ãƒƒã‚¯ï¼ˆå¤–éƒ¨åŸºæº–åˆã‚ã›ï¼‰
            const hasCalibrated = localStorage.getItem('hasCalibrated');
            if (!hasCalibrated) {
                showCalibrationModal();
            }
            
            // ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆæœŸåŒ–
            initCameraPreview();
            
            // IMUãƒ‡ãƒ¼ã‚¿å–å¾—é–‹å§‹
            startIMUMonitoring();
            
            // ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šï¼ˆè‡ªå‹•ï¼‰
            // PCã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è‡ªå‹•æ¤œå‡ºã¾ãŸã¯æ‰‹å‹•è¨­å®š
            const urlParams = new URLSearchParams(window.location.search);
            const pcIpFromUrl = urlParams.get('pcIp');
            const pcIpFromStorage = localStorage.getItem('pcIp');
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç¾åœ¨ã®PCã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆç’°å¢ƒã«å¿œã˜ã¦å¤‰æ›´ã—ã¦ãã ã•ã„ï¼‰
            // åˆ¥ã®PCã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¾ãŸã¯localStorageã§è¨­å®šå¯èƒ½
            const pcIp = pcIpFromUrl || pcIpFromStorage || 'YOUR_PC_IP_ADDRESS';
            connectToServer(pcIp);
            
            // ROIé¸æŠã‚¤ãƒ™ãƒ³ãƒˆ
            setupROISelection();
        });
        
        // ============================================================
        // å¤–éƒ¨åŸºæº–åˆã‚ã›ãƒ¢ãƒ¼ãƒ€ãƒ«
        // ============================================================
        function showCalibrationModal() {
            const modal = document.createElement('div');
            modal.className = 'modal fade show';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— - åŸºæº–åˆã‚ã›</h5>
                        </div>
                        <div class="modal-body">
                            <p>æ°´å¹³å™¨ã‚’ä½¿ã£ã¦ã€iPhoneã‚’æ°´å¹³ã«é…ç½®ã—ã¦ãã ã•ã„ã€‚</p>
                            <ol>
                                <li>iPhoneã‚’å£ã¾ãŸã¯ä¸‰è„šã«å›ºå®š</li>
                                <li>æ°´å¹³å™¨ã‚’iPhoneã®ç”»é¢ã«åˆã‚ã›ã‚‹</li>
                                <li>æ°´å¹³ã«ãªã£ãŸã‚‰ã€ŒåŸºæº–è¨­å®šã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™</li>
                            </ol>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" onclick="skipCalibration()">ã‚¹ã‚­ãƒƒãƒ—</button>
                            <button type="button" class="btn btn-primary" onclick="completeCalibration()">âœ… åŸºæº–è¨­å®šå®Œäº†</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            window.completeCalibration = function() {
                isCalibrated = true;
                localStorage.setItem('hasCalibrated', 'true');
                document.body.removeChild(modal);
                logMessage('âœ… å¤–éƒ¨åŸºæº–åˆã‚ã›å®Œäº†', 'success');
            };
            
            window.skipCalibration = function() {
                localStorage.setItem('hasCalibrated', 'skipped');
                document.body.removeChild(modal);
                logMessage('âš ï¸ å¤–éƒ¨åŸºæº–åˆã‚ã›ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆç«¯æœ«å†…ã‚­ãƒ£ãƒªãƒ–ã®ã¿ä½¿ç”¨ï¼‰', 'warning');
            };
        }
        
        // ============================================================
        // ã‚µãƒ¼ãƒãƒ¼æ¥ç¶š
        // ============================================================
        function connectToServer(pcIp) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${pcIp}:3000/ws/lidar`;
            
            logMessage(`ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šä¸­: ${wsUrl}`, 'info');
            updateConnectionStatus('connecting', 'æ¥ç¶šä¸­...');
            
            try {
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = function(event) {
                    logMessage('âœ… ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šæˆåŠŸ', 'success');
                    updateConnectionStatus('connected', 'æ¥ç¶šæ¸ˆã¿');
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleServerMessage(data);
                    } catch (error) {
                        logMessage(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    }
                };
                
                websocket.onclose = function(event) {
                    logMessage('âŒ ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', 'error');
                    updateConnectionStatus('disconnected', 'åˆ‡æ–­');
                };
                
                websocket.onerror = function(error) {
                    logMessage(`âŒ æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message || 'Unknown error'}`, 'error');
                    updateConnectionStatus('disconnected', 'ã‚¨ãƒ©ãƒ¼');
                };
                
            } catch (error) {
                logMessage(`âŒ WebSocketä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateConnectionStatus('disconnected', 'ã‚¨ãƒ©ãƒ¼');
            }
        }
        
        // ============================================================
        // ã‚µãƒ¼ãƒãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
        // ============================================================
        function handleServerMessage(data) {
            switch (data.type) {
                case 'connection':
                    logMessage(`ã‚µãƒ¼ãƒãƒ¼: ${data.message}`, 'info');
                    break;
                case 'angle_result':
                    currentMeasurement = data;
                    displayAngleResult(data);
                    document.getElementById('saveBtn').disabled = false;
                    logMessage(`âœ… è§’åº¦è¨ˆç®—å®Œäº†: ãƒ”ãƒƒãƒ=${data.pitch}Â°, ãƒ­ãƒ¼ãƒ«=${data.roll}Â°`, 'success');
                    break;
                case 'save_response':
                    logMessage(`âœ… è¨ˆæ¸¬çµæœã‚’ä¿å­˜ã—ã¾ã—ãŸ (ID: ${data.measurement_id})`, 'success');
                    document.getElementById('saveBtn').disabled = true;
                    break;
                case 'error':
                    logMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${data.message}`, 'error');
                    break;
                default:
                    logMessage(`æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—: ${data.type}`, 'warning');
            }
        }
        
        // ============================================================
        // ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆæœŸåŒ–
        // ============================================================
        async function initCameraPreview() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('ã‚«ãƒ¡ãƒ©APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚HTTPSæ¥ç¶šãŒå¿…è¦ã§ã™ã€‚');
                }
                
                const video = document.getElementById('cameraVideo');
                
                // èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆçš„ã«å–å¾—
                const constraints = {
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = cameraStream;
                
                logMessage('âœ… ã‚«ãƒ¡ãƒ©èµ·å‹•æˆåŠŸ', 'success');
                
                // ARKit/WebXRåˆæœŸåŒ–ï¼ˆLiDARå¯¾å¿œãƒã‚§ãƒƒã‚¯ï¼‰
                initARKit();
                
            } catch (error) {
                logMessage(`âŒ ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        // ============================================================
        // ARKit/WebXRåˆæœŸåŒ–
        // ============================================================
        async function initARKit() {
            try {
                // WebXR APIã‚’è©¦è¡Œï¼ˆiOS Safariã§ARãƒ¢ãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆï¼‰
                if (navigator.xr) {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (supported) {
                        logMessage('âœ… WebXR ARãƒ¢ãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ã§ã™', 'success');
                        await initWebXR();
                        return;
                    }
                }
                
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ã®ARKitãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰äº’æ›æ€§ã®ãŸã‚ä¿æŒï¼‰
                if (typeof ARKit !== 'undefined') {
                    if (!ARKit.ARWorldTrackingConfiguration.isSupported) {
                        logMessage('âš ï¸ ARWorldTrackingConfigurationãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warning');
                        useSimulationMode();
                        return;
                    }
                    
                    if (!ARKit.ARWorldTrackingConfiguration.supportsSceneReconstruction) {
                        logMessage('âš ï¸ ã‚·ãƒ¼ãƒ³å†æ§‹ç¯‰ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚LiDARãŒå¿…è¦ã§ã™ã€‚', 'warning');
                        useSimulationMode();
                        return;
                    }
                    
                    arSession = new ARKit.ARSession();
                    const configuration = new ARKit.ARWorldTrackingConfiguration();
                    configuration.sceneReconstruction = ARKit.ARWorldTrackingConfiguration.SceneReconstruction.mesh;
                    arSession.run(configuration);
                    
                    logMessage('âœ… ARKitã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ï¼ˆLiDARæœ‰åŠ¹ï¼‰', 'success');
                } else {
                    logMessage('âš ï¸ ARKit APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚', 'warning');
                    useSimulationMode();
                }
                
            } catch (error) {
                logMessage(`âŒ ARåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                useSimulationMode();
            }
        }
        
        // ============================================================
        // WebXRåˆæœŸåŒ–
        // ============================================================
        async function initWebXR() {
            try {
                // WebXRã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆï¼ˆå°†æ¥å®Ÿè£…ï¼‰
                logMessage('ğŸ“ WebXRå®Ÿè£…ã¯å°†æ¥æ‹¡å¼µäºˆå®šã§ã™', 'info');
                useSimulationMode();
            } catch (error) {
                logMessage(`âŒ WebXRåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                useSimulationMode();
            }
        }
        
        // ============================================================
        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼ˆé–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆç”¨ï¼‰
        // ============================================================
        function useSimulationMode() {
            logMessage('âš ï¸ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œã—ã¾ã™ï¼ˆå®Ÿãƒ‡ãƒã‚¤ã‚¹ã§ã¯LiDARãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ï¼‰', 'warning');
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            window.simulationMode = true;
        }
        
        // ============================================================
        // IMUãƒ‡ãƒ¼ã‚¿å–å¾—
        // ============================================================
        function startIMUMonitoring() {
            if (typeof DeviceMotionEvent !== 'undefined' && DeviceMotionEvent.requestPermission) {
                // iOS 13+ ã®å ´åˆã€è¨±å¯ãŒå¿…è¦
                DeviceMotionEvent.requestPermission().then(response => {
                    if (response === 'granted') {
                        startDeviceMotion();
                    } else {
                        logMessage('âš ï¸ ãƒ‡ãƒã‚¤ã‚¹ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨±å¯ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ', 'warning');
                    }
                });
            } else {
                startDeviceMotion();
            }
        }
        
        function startDeviceMotion() {
            window.addEventListener('devicemotion', function(event) {
                if (event.accelerationIncludingGravity) {
                    const acc = event.accelerationIncludingGravity;
                    imuData.gravity = {
                        x: acc.x || 0,
                        y: acc.y || 0,
                        z: acc.z || -9.8
                    };
                }
                
                if (event.rotationRate) {
                    const rot = event.rotationRate;
                    imuData.attitude = {
                        pitch: rot.beta || 0,
                        roll: rot.gamma || 0,
                        yaw: rot.alpha || 0
                    };
                }
            });
            
            logMessage('âœ… IMUãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹', 'success');
        }
        
        // ============================================================
        // ROIé¸æŠæ©Ÿèƒ½
        // ============================================================
        function setupROISelection() {
            const preview = document.getElementById('cameraPreview');
            const roiRect = document.getElementById('roiRectangle');
            
            // ã‚¿ãƒƒãƒ—ã§ROIé¸æŠ
            preview.addEventListener('click', function(event) {
                if (isMeasuring) {
                    logMessage('âš ï¸ è¨ˆæ¸¬ä¸­ã¯ROIã‚’å¤‰æ›´ã§ãã¾ã›ã‚“', 'warning');
                    return;
                }
                
                const rect = preview.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // ROIä¸­å¿ƒã‚’è¨­å®š
                createAutoROI(x, y, rect.width, rect.height);
            });
            
            // ROIæ‰‹å‹•èª¿æ•´ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ï¼‰
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            
            roiRect.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('roi-handle')) {
                    // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«
                    isDragging = true;
                    // TODO: ãƒªã‚µã‚¤ã‚ºå‡¦ç†
                } else {
                    // ç§»å‹•
                    isDragging = true;
                    const rect = roiRect.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                }
            });
            
            preview.addEventListener('mousemove', function(e) {
                if (isDragging && !isMeasuring) {
                    const previewRect = preview.getBoundingClientRect();
                    const newX = e.clientX - previewRect.left - dragOffset.x;
                    const newY = e.clientY - previewRect.top - dragOffset.y;
                    
                    roiRect.style.left = Math.max(0, Math.min(newX, previewRect.width - parseFloat(roiRect.style.width))) + 'px';
                    roiRect.style.top = Math.max(0, Math.min(newY, previewRect.height - parseFloat(roiRect.style.height))) + 'px';
                    
                    updateROIData();
                }
            });
            
            preview.addEventListener('mouseup', function() {
                isDragging = false;
            });
            
            // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œï¼‰
            roiRect.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = roiRect.getBoundingClientRect();
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
                isDragging = true;
            });
            
            preview.addEventListener('touchmove', function(e) {
                if (isDragging && !isMeasuring) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const previewRect = preview.getBoundingClientRect();
                    const newX = touch.clientX - previewRect.left - dragOffset.x;
                    const newY = touch.clientY - previewRect.top - dragOffset.y;
                    
                    roiRect.style.left = Math.max(0, Math.min(newX, previewRect.width - parseFloat(roiRect.style.width))) + 'px';
                    roiRect.style.top = Math.max(0, Math.min(newY, previewRect.height - parseFloat(roiRect.style.height))) + 'px';
                    
                    updateROIData();
                }
            });
            
            preview.addEventListener('touchend', function() {
                isDragging = false;
            });
        }
        
        function createAutoROI(centerX, centerY, canvasWidth, canvasHeight) {
            const roiRect = document.getElementById('roiRectangle');
            
            // è‡ªå‹•ROIã‚µã‚¤ã‚ºè¨ˆç®—ï¼ˆç”»é¢ã®30%ç¨‹åº¦ã€æœ€å°100pxï¼‰
            const roiWidth = Math.max(100, canvasWidth * 0.3);
            const roiHeight = Math.max(100, canvasHeight * 0.3);
            
            const left = Math.max(0, centerX - roiWidth / 2);
            const top = Math.max(0, centerY - roiHeight / 2);
            const right = Math.min(canvasWidth, centerX + roiWidth / 2);
            const bottom = Math.min(canvasHeight, centerY + roiHeight / 2);
            
            roiRect.style.left = left + 'px';
            roiRect.style.top = top + 'px';
            roiRect.style.width = (right - left) + 'px';
            roiRect.style.height = (bottom - top) + 'px';
            roiRect.style.display = 'block';
            
            updateROIData();
            
            logMessage(`ğŸ“ ROIé¸æŠå®Œäº† (ä¸­å¿ƒ: ${centerX.toFixed(0)}, ${centerY.toFixed(0)}, ã‚µã‚¤ã‚º: ${(right-left).toFixed(0)}x${(bottom-top).toFixed(0)})`, 'success');
        }
        
        function updateROIData() {
            const roiRect = document.getElementById('roiRectangle');
            const preview = document.getElementById('cameraPreview');
            const previewRect = preview.getBoundingClientRect();
            const roiRectBounds = roiRect.getBoundingClientRect();
            
            const centerX = (roiRectBounds.left + roiRectBounds.width / 2 - previewRect.left) / previewRect.width;
            const centerY = (roiRectBounds.top + roiRectBounds.height / 2 - previewRect.top) / previewRect.height;
            
            roiData = {
                center: { 
                    x: centerX,
                    y: centerY,
                    z: 1.0  // æš«å®šå€¤
                },
                size: { 
                    width: roiRectBounds.width / previewRect.width,
                    height: roiRectBounds.height / previewRect.height,
                    depth: 0.2  // æš«å®šå€¤ï¼ˆ20cmï¼‰
                }
            };
        }
        
        // ============================================================
        // å¯¾è±¡ã‚¿ã‚¤ãƒ—é¸æŠ
        // ============================================================
        function selectTargetType(type) {
            currentTargetType = type;
            
            // ã‚¿ãƒ–ã®è¦‹ãŸç›®ã‚’æ›´æ–°
            document.querySelectorAll('.target-type-tabs .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.target-type-tabs .btn[data-type="${type}"]`).classList.add('active');
            
            logMessage(`å¯¾è±¡ã‚¿ã‚¤ãƒ—ã‚’é¸æŠ: ${type}`, 'info');
        }
        
        // ============================================================
        // åŸºæº–åˆã‚ã›
        // ============================================================
        function startCalibration() {
            logMessage('ğŸ“ åŸºæº–åˆã‚ã›ã‚’é–‹å§‹ã—ã¾ã™...', 'info');
            
            // å¤–éƒ¨åŸºæº–åˆã‚ã›ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
            const modal = document.createElement('div');
            modal.className = 'modal fade show';
            modal.style.display = 'block';
            modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
            modal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">ğŸ“ åŸºæº–åˆã‚ã›</h5>
                        </div>
                        <div class="modal-body">
                            <p>æ°´å¹³å™¨ã‚’ä½¿ã£ã¦ã€iPhoneã‚’æ°´å¹³ã«é…ç½®ã—ã¦ãã ã•ã„ã€‚</p>
                            <ol>
                                <li>iPhoneã‚’å£ã¾ãŸã¯ä¸‰è„šã«å›ºå®š</li>
                                <li>æ°´å¹³å™¨ã‚’iPhoneã®ç”»é¢ã«åˆã‚ã›ã‚‹</li>
                                <li>æ°´å¹³ã«ãªã£ãŸã‚‰ã€ŒåŸºæº–è¨­å®šå®Œäº†ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™</li>
                            </ol>
                            <div class="alert alert-info mt-3">
                                <strong>ç¾åœ¨ã®IMUãƒ‡ãƒ¼ã‚¿:</strong><br>
                                ãƒ”ãƒƒãƒ: <span id="calibrationPitch">0.0</span>Â°<br>
                                ãƒ­ãƒ¼ãƒ«: <span id="calibrationRoll">0.0</span>Â°
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" onclick="closeCalibrationModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                            <button type="button" class="btn btn-primary" onclick="completeCalibration()">âœ… åŸºæº–è¨­å®šå®Œäº†</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // IMUãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º
            const calibrationInterval = setInterval(() => {
                const pitch = (imuData.attitude.pitch * 180 / Math.PI).toFixed(1);
                const roll = (imuData.attitude.roll * 180 / Math.PI).toFixed(1);
                const pitchEl = document.getElementById('calibrationPitch');
                const rollEl = document.getElementById('calibrationRoll');
                if (pitchEl) pitchEl.textContent = pitch;
                if (rollEl) rollEl.textContent = roll;
            }, 100);
            
            window.completeCalibration = function() {
                clearInterval(calibrationInterval);
                isCalibrated = true;
                localStorage.setItem('hasCalibrated', 'true');
                localStorage.setItem('calibrationTimestamp', new Date().toISOString());
                localStorage.setItem('calibrationIMU', JSON.stringify(imuData));
                document.body.removeChild(modal);
                logMessage('âœ… å¤–éƒ¨åŸºæº–åˆã‚ã›å®Œäº†', 'success');
            };
            
            window.closeCalibrationModal = function() {
                clearInterval(calibrationInterval);
                document.body.removeChild(modal);
            };
        }
        
        // ============================================================
        // è¨ˆæ¸¬é–‹å§‹
        // ============================================================
        function startMeasurement() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                logMessage('âŒ ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šãŒå¿…è¦ã§ã™', 'error');
                return;
            }
            
            if (!roiData) {
                logMessage('âŒ ã¾ãšROIã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            logMessage('ğŸ“ è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã™...', 'info');
            isMeasuring = true;
            
            // LiDARç‚¹ç¾¤ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ»é€ä¿¡
            captureAndSendLiDARData();
        }
        
        // ============================================================
        // LiDARãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ»é€ä¿¡
        // ============================================================
        function captureAndSendLiDARData() {
            let sceneDepth = null;
            let camera = null;
            
            // ARKitã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚’è©¦è¡Œ
            if (arSession && arSession.currentFrame) {
                try {
                    const currentFrame = arSession.currentFrame;
                    sceneDepth = currentFrame.sceneDepth;
                    camera = currentFrame.camera;
                } catch (error) {
                    logMessage(`âš ï¸ ARKitãƒ•ãƒ¬ãƒ¼ãƒ å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'warning');
                }
            }
            
            // ç‚¹ç¾¤ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆROIç¯„å›²å†…ï¼‰
            // sceneDepthãŒnullã®å ´åˆã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ç”Ÿæˆ
            const points = generatePointCloudInROI(sceneDepth, camera);
            
            if (points.length === 0) {
                logMessage('âš ï¸ ç‚¹ç¾¤ãƒ‡ãƒ¼ã‚¿ãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ', 'warning');
                isMeasuring = false;
                return;
            }
            
            // åŸºæº–æ–¹å¼ã‚’å–å¾—
            const basisRadio = document.querySelector('input[name="basis"]:checked');
            currentBasis = basisRadio ? basisRadio.value : 'imu';
            
            // è·é›¢è¨ˆç®—ï¼ˆæš«å®šï¼šROIä¸­å¿ƒã®Zåº§æ¨™ã‹ã‚‰æ¨å®šï¼‰
            const avgZ = points.reduce((sum, p) => sum + p[2], 0) / points.length;
            const distance = avgZ.toFixed(2);
            document.getElementById('distance').textContent = `${distance} m`;
            
            // ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
            const message = {
                type: 'lidar_data',
                points: points.map(p => ({
                    x: p[0],
                    y: p[1],
                    z: p[2],
                    confidence: 0.95
                })),
                roi: roiData,
                imu: {
                    gravity: imuData.gravity,
                    attitude: imuData.attitude,
                    timestamp: new Date().toISOString()
                },
                container_id: 'CNT-TEST',  // æš«å®š
                target_type: currentTargetType,
                basis: currentBasis,
                timestamp: new Date().toISOString()
            };
            
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                logMessage('âŒ ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šãŒå¿…è¦ã§ã™', 'error');
                isMeasuring = false;
                return;
            }
            
            websocket.send(JSON.stringify(message));
            
            // çµ±è¨ˆæ›´æ–°
            document.getElementById('pointCount').textContent = `${points.length}ç‚¹`;
            
            logMessage(`ğŸ“¡ LiDARãƒ‡ãƒ¼ã‚¿é€ä¿¡: ${points.length}ç‚¹`, 'info');
            
            isMeasuring = false;
        }
        
        // ============================================================
        // ç‚¹ç¾¤ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆROIç¯„å›²å†…ï¼‰
        // ============================================================
        function generatePointCloudInROI(sceneDepth, camera) {
            const points = [];
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ
            if (window.simulationMode) {
                return generateSimulatedPointCloud();
            }
            
            // å®Ÿéš›ã®LiDARç‚¹ç¾¤ç”Ÿæˆï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‚è€ƒï¼‰
            try {
                if (!sceneDepth || !camera) {
                    logMessage('âš ï¸ ã‚·ãƒ¼ãƒ³æ·±åº¦ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯ã‚«ãƒ¡ãƒ©ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'warning');
                    return generateSimulatedPointCloud();
                }
                
                const depthData = sceneDepth.depthMap;
                if (!depthData) {
                    logMessage('âš ï¸ æ·±åº¦ãƒãƒƒãƒ—ãŒå–å¾—ã§ãã¾ã›ã‚“', 'warning');
                    return generateSimulatedPointCloud();
                }
                
                const width = depthData.width || 640;
                const height = depthData.height || 480;
                
                // ã‚«ãƒ¡ãƒ©ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                const cameraIntrinsics = camera.intrinsics;
                const fx = cameraIntrinsics?.[0]?.[0] || width * 0.8;
                const fy = cameraIntrinsics?.[1]?.[1] || height * 0.8;
                const cx = cameraIntrinsics?.[0]?.[2] || width / 2;
                const cy = cameraIntrinsics?.[1]?.[2] || height / 2;
                
                // ROIç¯„å›²ã‚’è€ƒæ…®ã—ãŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                const roiRect = document.getElementById('roiRectangle');
                if (!roiRect || roiRect.style.display === 'none') {
                    // ROIæœªé¸æŠã®å ´åˆã¯å…¨ä½“ã‹ã‚‰ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                    return generateSimulatedPointCloud();
                }
                
                const previewRect = document.getElementById('cameraPreview').getBoundingClientRect();
                const roiRectBounds = roiRect.getBoundingClientRect();
                
                const roiX = roiRectBounds.left - previewRect.left;
                const roiY = roiRectBounds.top - previewRect.top;
                const roiW = roiRectBounds.width;
                const roiH = roiRectBounds.height;
                
                // ROIç¯„å›²å†…ã®æ·±åº¦ãƒ‡ãƒ¼ã‚¿ã‚’ç‚¹ç¾¤ã«å¤‰æ›ï¼ˆ4ãƒ”ã‚¯ã‚»ãƒ«é–“éš”ã§ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
                const step = 4;
                const startY = Math.max(0, Math.floor(roiY * height / previewRect.height));
                const endY = Math.min(height, Math.floor((roiY + roiH) * height / previewRect.height));
                const startX = Math.max(0, Math.floor(roiX * width / previewRect.width));
                const endX = Math.min(width, Math.floor((roiX + roiW) * width / previewRect.width));
                
                for (let y = startY; y < endY; y += step) {
                    for (let x = startX; x < endX; x += step) {
                        const depth = getDepthValue(depthData, x, y);
                        
                        if (depth > 0 && depth < 5.0) { // 5ãƒ¡ãƒ¼ãƒˆãƒ«ä»¥å†…ã®ç‚¹ã®ã¿
                            // 3Dåº§æ¨™ã«å¤‰æ›
                            const z = depth;
                            const x3d = (x - cx) * z / fx;
                            const y3d = (y - cy) * z / fy;
                            
                            points.push([x3d, y3d, z]);
                        }
                    }
                }
                
                // ç‚¹æ•°ãŒå°‘ãªã„å ´åˆã¯è£œé–“
                if (points.length < 50) {
                    logMessage('âš ï¸ ç‚¹ç¾¤ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã„ãŸã‚ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’è£œå®Œã—ã¾ã™', 'warning');
                    const simulated = generateSimulatedPointCloud();
                    points.push(...simulated.slice(0, 50 - points.length));
                }
                
                return points;
                
            } catch (error) {
                logMessage(`âŒ ç‚¹ç¾¤ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                return generateSimulatedPointCloud();
            }
        }
        
        // ============================================================
        // æ·±åº¦å€¤å–å¾—
        // ============================================================
        function getDepthValue(depthData, x, y) {
            // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€CVPixelBufferã‹ã‚‰æ·±åº¦å€¤ã‚’å–å¾—
            // æš«å®šå®Ÿè£…ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
            try {
                // depthDataã‹ã‚‰å®Ÿéš›ã®æ·±åº¦å€¤ã‚’å–å¾—ã™ã‚‹å‡¦ç†
                // CVPixelBufferã®ã‚¢ã‚¯ã‚»ã‚¹æ–¹æ³•ã¯ç’°å¢ƒä¾å­˜
                return Math.random() * 2.0 + 0.5; // 0.5-2.5mã®ç¯„å›²
            } catch (error) {
                return Math.random() * 2.0 + 0.5;
            }
        }
        
        // ============================================================
        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç‚¹ç¾¤ç”Ÿæˆï¼ˆé–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆç”¨ï¼‰
        // ============================================================
        function generateSimulatedPointCloud() {
            const points = [];
            const sampleCount = 500;  // 500ç‚¹ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            
            // ROIç¯„å›²ã‚’è€ƒæ…®ã—ãŸã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            const roiRect = document.getElementById('roiRectangle');
            let centerX = 0.0;
            let centerY = 0.0;
            let centerZ = 1.0;
            let spreadX = 0.3;
            let spreadY = 0.2;
            let spreadZ = 0.3;
            
            if (roiRect && roiRect.style.display !== 'none') {
                // ROIãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ç¯„å›²ã«åˆã‚ã›ã¦ç”Ÿæˆ
                const previewRect = document.getElementById('cameraPreview').getBoundingClientRect();
                const roiRectBounds = roiRect.getBoundingClientRect();
                const roiCenterX = (roiRectBounds.left + roiRectBounds.width / 2 - previewRect.left) / previewRect.width;
                const roiCenterY = (roiRectBounds.top + roiRectBounds.height / 2 - previewRect.top) / previewRect.height;
                
                centerX = (roiCenterX - 0.5) * 0.5;
                centerY = (roiCenterY - 0.5) * 0.3;
                spreadX = roiRectBounds.width / previewRect.width * 0.5;
                spreadY = roiRectBounds.height / previewRect.height * 0.3;
            }
            
            for (let i = 0; i < sampleCount; i++) {
                points.push([
                    centerX + (Math.random() - 0.5) * spreadX,
                    centerY + (Math.random() - 0.5) * spreadY,
                    centerZ + (Math.random() - 0.5) * spreadZ
                ]);
            }
            
            return points;
        }
        
        // ============================================================
        // è§’åº¦çµæœè¡¨ç¤º
        // ============================================================
        function displayAngleResult(data) {
            // TODO: è§’åº¦çµæœã‚’UIã«è¡¨ç¤ºï¼ˆSprint 2è©³ç´°å®Ÿè£…ï¼‰
            logMessage(`è§’åº¦çµæœ: ãƒ”ãƒƒãƒ=${data.pitch}Â°, ãƒ­ãƒ¼ãƒ«=${data.roll}Â°`, 'success');
        }
        
        // ============================================================
        // ä¿å­˜
        // ============================================================
        function saveMeasurement() {
            if (!currentMeasurement) {
                logMessage('âŒ ä¿å­˜ã™ã‚‹è¨ˆæ¸¬çµæœãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }
            
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                logMessage('âŒ ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šãŒå¿…è¦ã§ã™', 'error');
                return;
            }
            
            const message = {
                type: 'save_measurement',
                measurement_id: currentMeasurement.measurement_id,
                container_id: 'CNT-TEST',
                container_number: 'CNT-TEST',
                processed_date: new Date().toISOString().split('T')[0],
                operator: 'user'
            };
            
            websocket.send(JSON.stringify(message));
            logMessage('ğŸ’¾ ä¿å­˜ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡', 'info');
        }
        
        // ============================================================
        // æ¬¡ã®æ¸¬å®š
        // ============================================================
        function nextMeasurement() {
            // ROIã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('roiRectangle').style.display = 'none';
            roiData = null;
            currentMeasurement = null;
            document.getElementById('saveBtn').disabled = true;
            
            logMessage('â¡ï¸ æ¬¡ã®æ¸¬å®šã‚’æº–å‚™ã—ã¾ã—ãŸ', 'info');
        }
        
        // ============================================================
        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        // ============================================================
        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logDiv = document.createElement('div');
            logDiv.className = `log-message log-${type}`;
            logDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logDiv);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function updateConnectionStatus(status, text) {
            const statusIndicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('connectionText');
            
            statusIndicator.className = `status-indicator status-${status}`;
            statusText.textContent = text;
        }
    </script>
</body>
</html>

